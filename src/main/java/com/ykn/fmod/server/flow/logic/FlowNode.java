/**
 * Copyright (c) ykn
 * This file is under the MIT License
 */

package com.ykn.fmod.server.flow.logic;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import com.ykn.fmod.server.base.util.Util;
import com.ykn.fmod.server.flow.tool.NodeRegistry;

import net.minecraft.text.MutableText;
import net.minecraft.text.Text;

/**
 * Represents a node in a logic flow that can process inputs, produce outputs, and connect to other nodes.
 * <p>
 * FlowNode is the base class for all nodes in the logic flow system. Each node has:
 * <ul>
 *   <li>A unique identifier (id)</li>
 *   <li>Input ports that can reference constants or outputs from other nodes</li>
 *   <li>Output ports that produce values during execution</li>
 *   <li>Branch connections to next nodes in the flow</li>
 *   <li>Metadata describing the node's interface and properties</li>
 * </ul>
 * <p>
 * Nodes are executed within an {@link ExecutionContext} and can be connected together to form
 * complex logic flows. Subclasses should override {@link #onExecute} to implement specific functionality.
 * <p>
 * This class implements {@link Cloneable} to support flow duplication.
 * 
 * @see ExecutionContext
 * @see LogicFlow
 * @see DataReference
 * @see NodeMetadata
 */
public class FlowNode implements Cloneable {

    /**
     * The unique identifier for this node within its logic flow.
     * This ID is generated by the {@link LogicFlow} and must be unique within that flow.
     */
    private final long id;

    /**
     * The type name of this node, used for node registration and factory creation.
     * This should match the type name used in {@link com.ykn.fmod.server.flow.tool.NodeRegistry}.
     */
    protected String type;

    /**
     * The user-defined name of this node instance.
     * This name can be used to identify the node in the UI and for debugging purposes.
     */
    protected String name;

    /**
     * The static information about this node.
     * Should not be serialized because it just contains the static information about this node type.
     * We can already have this information from the type of this node.
     * <p>
     * The metadata includes:
     * <ul>
     *   <li>Display name and description for UI rendering</li>
     *   <li>Number of inputs, outputs, and branches</li>
     *   <li>Names and descriptions for each input, output, and branch</li>
     *   <li>Data type information for inputs and outputs</li>
     * </ul>
     */
    protected final transient NodeMetadata metadata;

    /**
     * The list of input data references for this node.
     * Each input can be either a constant value or a reference to another node's output.
     * 
     * @see DataReference
     */
    private final List<DataReference> inputs;

    /**
     * The list of IDs of the next nodes to execute after this node.
     * Each entry corresponds to a branch from this node. A value of -1 indicates no next node.
     * The number of entries matches the branch number defined in the metadata.
     */
    private final List<Long> nextNodeIds;

    /**
     * Constructs a new FlowNode with the specified configuration.
     * <p>
     * This constructor initializes:
     * <ul>
     *   <li>All inputs with empty references</li>
     *   <li>All next node IDs to -1 (no connection)</li>
     *   <li>The node metadata by calling {@link #createMetadata}</li>
     * </ul>
     * 
     * @param id The unique identifier for this node
     * @param name The user-defined name for this node
     * @param inputNumber The number of input ports this node has
     * @param outputNumber The number of output ports this node has
     * @param branchNumber The number of branch connections this node has
     */
    public FlowNode(long id, String name, int inputNumber, int outputNumber, int branchNumber) {
        this.id = id;
        this.type = "AbstractNode";
        this.name = name;
        this.inputs = new ArrayList<>();
        for (int i = 0; i < inputNumber; i++) {
            this.inputs.add(DataReference.createEmptyReference());
        }
        this.nextNodeIds = new ArrayList<>();
        for (int i = 0; i < branchNumber; i++) {
            this.nextNodeIds.add(-1L);
        }
        this.metadata = createMetadata(inputNumber, outputNumber, branchNumber);
    }

    /**
     * Creates the metadata for this node type.
     * <p>
     * Subclasses should override this method to provide specific metadata for their node type,
     * including custom display names, descriptions, and input/output specifications.
     * The default implementation creates generic metadata with placeholder text.
     * 
     * @param inputNumber The number of inputs for this node
     * @param outputNumber The number of outputs for this node
     * @param branchNumber The number of branches for this node
     * @return A NodeMetadata object containing the static information about this node
     */
    protected NodeMetadata createMetadata(int inputNumber, int outputNumber, int branchNumber) {
        // Should be overridden by subclasses to provide specific metadata
        Text displayName = Util.parseTranslatableText("fmod.node.abstract.title.name");
        Text description = Util.parseTranslatableText("fmod.node.abstract.title.feat");
        List<Text> inputNames = new ArrayList<>();
        List<Text> inputDescriptions = new ArrayList<>();
        List<Text> inputDataTypes = new ArrayList<>();
        for (int i = 0; i < inputNumber; i++) {
            inputNames.add(Util.parseTranslatableText("fmod.node.abstract.input.name", String.valueOf(i)));
            inputDescriptions.add(Util.parseTranslatableText("fmod.node.abstract.input.feat", String.valueOf(i)));
            inputDataTypes.add(Util.parseTranslatableText("fmod.node.abstract.input.type"));
        }
        List<Text> outputNames = new ArrayList<>();
        List<Text> outputDescriptions = new ArrayList<>();
        List<Text> outputDataTypes = new ArrayList<>();
        for (int i = 0; i < outputNumber; i++) {
            outputNames.add(Util.parseTranslatableText("fmod.node.abstract.output.name", String.valueOf(i)));
            outputDescriptions.add(Util.parseTranslatableText("fmod.node.abstract.output.feat", String.valueOf(i)));
            outputDataTypes.add(Util.parseTranslatableText("fmod.node.abstract.output.type"));
        }
        List<Text> branchNames = new ArrayList<>();
        List<Text> branchDescriptions = new ArrayList<>();
        for (int i = 0; i < branchNumber; i++) {
            branchNames.add(Util.parseTranslatableText("fmod.node.abstract.branch.name", String.valueOf(i)));
            branchDescriptions.add(Util.parseTranslatableText("fmod.node.abstract.branch.feat", String.valueOf(i)));
        }
        return new NodeMetadata(inputNumber, outputNumber, branchNumber, displayName, description, 
            inputNames, inputDescriptions, inputDataTypes, outputNames, outputDescriptions, outputDataTypes, branchNames, branchDescriptions);
    } 

    /**
     * Resolves all input references to their actual values.
     * <p>
     * This method iterates through all inputs and resolves each {@link DataReference}
     * to its actual value, either from a constant or from another node's output.
     * 
     * @param context The execution context containing node statuses and variables
     * @return A list of resolved input values in the same order as the inputs
     * @throws LogicException If any input reference is null or cannot be resolved
     */
    protected List<Object> resolveInputs(ExecutionContext context) throws LogicException {
        List<Object> resolvedInputs = new ArrayList<>();
        for (DataReference inputRef : inputs) {
            if (inputRef == null) {
                throw new LogicException(null, Util.parseTranslatableText("fmod.flow.error.nullinput", this.name), null);
            } else {
                Object resolvedValue = inputRef.resolve(context, this);
                resolvedInputs.add(resolvedValue);
            }
        }
        return resolvedInputs;
    }

    /**
     * Executes this node within the given execution context.
     * <p>
     * The execution process:
     * <ol>
     *   <li>Retrieves the node status from the context</li>
     *   <li>Resolves all input values</li>
     *   <li>Calls {@link #onExecute} to perform node-specific logic</li>
     *   <li>Determines the next node to execute</li>
     *   <li>Marks the node as executed and records the next branch</li>
     * </ol>
     * <p>
     * Note: A node can be executed multiple times in the same context due to loops.
     * 
     * @param context The execution context containing flow state and variables
     * @return The next node to execute, or null if the flow should terminate
     * @throws LogicException If an error occurs during execution
     */
    public FlowNode execute(ExecutionContext context) throws LogicException {
        // Executed multiple times is expected because we allow loops in logic flows, so no need to check hasExecuted here.
        NodeStatus status = context.getNodeStatus(this.id);
        if (status == null) {
            throw new LogicException(null, Util.parseTranslatableText("fmod.flow.error.nullself", this.name), null);
        }
        List<Object> resolvedInputs = resolveInputs(context);
        status.setInputs(resolvedInputs);
        this.onExecute(context, status, resolvedInputs);
        long nextNodeId = this.getNextNodeId(context, status, resolvedInputs);
        status.setExecuted();
        status.setNextBranchId(nextNodeId);
        return context.getFlow().getNode(nextNodeId);
    }

    /**
     * Performs the node-specific execution logic.
     * <p>
     * Subclasses should override this method to implement their specific functionality.
     * This method should:
     * <ul>
     *   <li>Process the resolved input values</li>
     *   <li>Write output values using {@link #setOutput}</li>
     *   <li>Throw {@link LogicException} if errors occur</li>
     * </ul>
     * <p>
     * The default implementation does nothing.
     * 
     * @param context The execution context
     * @param status The status object for this node in the current execution
     * @param resolvedInputs The list of resolved input values
     * @throws LogicException If an error occurs during node execution
     */
    protected void onExecute(ExecutionContext context, NodeStatus status, List<Object> resolvedInputs) throws LogicException {
        // To be overridden by subclasses to implement specific node logic
    }

    /**
     * Gets the unique identifier of this node.
     * 
     * @return The node's unique ID within its logic flow
     */
    public long getId() {
        return this.id;
    }

    /**
     * Gets the type name of this node.
     * 
     * @return The type string used for node registration
     */
    public String getType() {
        return this.type;
    }

    /**
     * Gets the metadata describing this node's interface.
     * 
     * @return The NodeMetadata object containing static information about this node
     */
    public NodeMetadata getMetadata() {
        return this.metadata;
    }

    /**
     * Gets an unmodifiable list of the input data references for this node.
     * @return An unmodifiable list of DataReference objects representing the inputs
     */
    public List<DataReference> getInputs() {
        return Collections.unmodifiableList(this.inputs);
    }

    /**
     * Gets the data reference for the specified input port.
     * 
     * @param index The index of the input port (0-based)
     * @return The DataReference for the specified input
     * @throws IndexOutOfBoundsException If the index is out of range
     */
    public DataReference getInput(int index) {
        return inputs.get(index);
    }

    /**
     * Sets the data reference for the specified input port.
     * 
     * @param index The index of the input port (0-based)
     * @param reference The DataReference to assign to this input
     * @throws IndexOutOfBoundsException If the index is out of range
     */
    public void setInput(int index, DataReference reference) {
        inputs.set(index, reference);
    }

    /**
     * Gets the output value from the specified output port.
     * <p>
     * This method can only be called after the node has been executed in the given context.
     * 
     * @param context The execution context
     * @param index The index of the output port (0-based)
     * @return The output value
     * @throws LogicException If the node has not been executed yet
     * @throws IndexOutOfBoundsException If the index is out of range
     */
    public Object getOutput(ExecutionContext context, int index) throws LogicException {
        NodeStatus status = context.getNodeStatus(this.id);
        if (status == null) {
            throw new LogicException(null, Util.parseTranslatableText("fmod.flow.error.nullself", this.name), null);
        } else if (!status.isExecuted()) {
            throw new LogicException(null, Util.parseTranslatableText("fmod.flow.error.notexecuted", this.name), null);
        }
        return status.getOutputs().get(index);
    }

    /**
     * Sets the output value for the specified output port.
     * <p>
     * This method should be called from within {@link #onExecute} to produce output values.
     * 
     * @param context The execution context
     * @param index The index of the output port (0-based)
     * @param value The value to set as output
     */
    protected void setOutput(ExecutionContext context, int index, Object value) throws LogicException {
        NodeStatus status = context.getNodeStatus(this.id);
        if (status == null) {
            throw new LogicException(null, Util.parseTranslatableText("fmod.flow.error.nullself", this.name), null);
        }
        status.setOutput(index, value);
    }

    /**
     * This method indicates whether this node is an event node.
     * Event nodes should always be the starting point of a logic flow execution.
     * And the event nodes will be automatically triggered by the system when the corresponding event occurs.
     * By default, nodes are not event nodes. Override this method in subclasses to specify event nodes.
     * @return true if this node is an event node, false otherwise
     */
    public boolean isEventNode() {
        // Override in subclasses to specify event nodes
        return false;
    }

    /**
     * Determines the ID of the next node to execute based on this node's logic.
     * <p>
     * The default implementation returns the first branch (index 0).
     * Nodes with multiple branches (e.g., conditional nodes) should override this
     * to return the appropriate branch based on their logic.
     * 
     * @param context The execution context
     * @param status The status object for this node
     * @param resolvedInputs The list of resolved input values
     * @return The ID of the next node to execute, or -1 to terminate the flow
     * @throws LogicException If an error occurs while determining the next node
     */
    public long getNextNodeId(ExecutionContext context, NodeStatus status, List<Object> resolvedInputs) throws LogicException {
        // Should be overridden to return the correct next node ID based on the node logic
        if (this.metadata.branchNumber == 0) {
            return -1L; // No branches, terminate the flow
        }
        return nextNodeIds.get(0);
    }
    
    /**
     * Sets the next node ID for the specified branch.
     * 
     * @param branchIndex The index of the branch (0-based)
     * @param nodeId The ID of the next node, or -1 for no connection
     * @throws IndexOutOfBoundsException If the branch index is out of range
     */
    public void setNextNodeId(int branchIndex, long nodeId) {
        this.nextNodeIds.set(branchIndex, nodeId);
    }

    /**
     * Gets an unmodifiable list of the next node IDs for all branches.
     * @return An unmodifiable list of next node IDs
     */
    public List<Long> getNextNodeIds() {
        return Collections.unmodifiableList(this.nextNodeIds);
    }

    /**
     * Gets the user-defined name of this node instance.
     * @return The name of this node
     */
    public String getName() {
        return this.name;
    }

    /**
     * Sets the user-defined name of this node instance.
     * @param name The new name for this node
     */
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Creates a deep copy of this node.
     * <p>
     * The copy includes:
     * <ul>
     *   <li>All input references (copied)</li>
     *   <li>All next node IDs</li>
     *   <li>The same ID, name, and type</li>
     * </ul>
     * <p>
     * Note: This uses {@link com.ykn.fmod.server.flow.tool.NodeRegistry} to preserve
     * the correct subclass type.
     * 
     * @return A new FlowNode instance with the same configuration
     */
    public FlowNode copy() {
        // Need to keep child class type here, so using NodeRegistry instead of new FlowNode(...)
        FlowNode newNode = NodeRegistry.createNode(this.type, this.id, this.name);
        if (newNode == null) {
            throw new IllegalStateException("The Node " + this.name + " must be registered in NodeRegistry as " + this.type + " before copying.");
        }
        for (int i = 0; i < this.metadata.inputNumber; i++) {
            DataReference inputRef = this.inputs.get(i);
            newNode.inputs.set(i, inputRef.copy());
        }
        for (int i = 0; i < this.nextNodeIds.size(); i++) {
            long nextNodeId = this.nextNodeIds.get(i);
            newNode.nextNodeIds.set(i, nextNodeId);
        }
        return newNode;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return this.copy();
    }

    /**
     * Verifies the integrity of this flow node by checking its configuration against expected values.
     * 
     * <p>This method performs the following validation checks:
     * <ul>
     *   <li>Ensures the node ID is non-negative</li>
     *   <li>Verifies the node type is registered in either NodeRegistry's node list or event node list</li>
     *   <li>Validates the node's metadata integrity</li>
     *   <li>Checks that the number of inputs matches the metadata definition</li>
     *   <li>Checks that the number of branches matches the metadata definition</li>
     * </ul>
     * </p>
     * 
     * <p>All validation failures are logged as warnings with details about the node and the specific issue.
     * The method aggregates all validation results and returns false if any check fails.</p>
     * 
     * @return {@code true} if all integrity checks pass, {@code false} if any validation fails
     * @see FlowNodeMetadata#verifyMetadataIntegrity()
     */
    public boolean verifyIntegrity() {
        boolean passed = true;
        if (this.id < 0) {
            Util.LOGGER.warn("FMinecraftMod: Node " + this.name + " has an invalid ID: " + this.id);
            passed = false;
        }
        if (!NodeRegistry.getNodeList().contains(this.type) && !NodeRegistry.getEventNodeList().contains(this.type)) {
            Util.LOGGER.warn("FMinecraftMod: Node " + this.name + " has an unregistered type: " + this.type);
            passed = false;
        }
        passed = this.metadata.verifyMetadataIntegrity() && passed;
        if (this.inputs.size() != this.metadata.inputNumber) {
            Util.LOGGER.warn("FMinecraftMod: Node " + this.name + " has " + this.inputs.size() + " inputs but metadata defines " + this.metadata.inputNumber);
            passed = false;
        }
        if (this.nextNodeIds.size() != this.metadata.branchNumber) {
            Util.LOGGER.warn("FMinecraftMod: Node " + this.name + " has " + this.nextNodeIds.size() + " branches but metadata defines " + this.metadata.branchNumber);
            passed = false;
        }
        return passed;
    }

    /**
     * Renders the static information about this node as displayable text.
     * <p>
     * The rendered text includes:
     * <ul>
     *   <li>Node name, display name, and description</li>
     *   <li>All input ports with their sources (constants or node outputs)</li>
     *   <li>All output ports with their descriptions</li>
     *   <li>Branch connections to next nodes</li>
     * </ul>
     * <p>
     * Note: This only renders static information. To render execution status,
     * use {@link NodeStatus#render(long, LogicFlow)} instead.
     * 
     * @param flow The logic flow containing this node (used to resolve node references)
     * @return A Text object suitable for display in Minecraft
     */
    public Text render(LogicFlow flow) {
        // Render title
        MutableText text = Util.parseTranslatableText("fmod.flow.node.title", this.name, this.metadata.displayName, this.metadata.description);
        text = text.append("\n");
        // Render inputs
        for (int i = 0; i < this.metadata.inputNumber; i++) {
            DataReference inputRef = this.inputs.get(i);
            MutableText inputLine = Util.parseTranslatableText("fmod.flow.node.input", this.metadata.inputNames.get(i), this.metadata.inputDescriptions.get(i));
            // Render optional info about the input source
            if (inputRef != null) {
                if (inputRef.getType() == DataReference.ReferenceType.CONSTANT && inputRef.getValue() != null) {
                    inputLine = inputLine.append(" (");
                    inputLine = inputLine.append(Util.parseTranslatableText("fmod.flow.node.const", String.valueOf(inputRef.getValue())));
                    inputLine = inputLine.append(")");
                } else if (inputRef.getType() == DataReference.ReferenceType.NODE_OUTPUT) {
                    FlowNode refNode = flow.getNode(inputRef.getReferenceId());
                    if (refNode != null && inputRef.getReferenceIndex() >= 0 && inputRef.getReferenceIndex() < refNode.metadata.outputNumber) {
                        inputLine = inputLine.append(" (");
                        inputLine = inputLine.append(Util.parseTranslatableText("fmod.flow.node.from", refNode.name, refNode.metadata.outputNames.get(inputRef.getReferenceIndex())));
                        inputLine = inputLine.append(")");
                    }
                }
            }
            text = text.append(inputLine).append("\n");
        }
        // Render outputs
        for (int i = 0; i < this.metadata.outputNumber; i++) {
            MutableText outputLine = Util.parseTranslatableText("fmod.flow.node.output", this.metadata.outputNames.get(i), this.metadata.outputDescriptions.get(i));
            text = text.append(outputLine).append("\n");
        }
        // Render branches
        if (this.metadata.branchNumber == 1) {
            // Directly show the next node
            long nextNodeId = this.nextNodeIds.get(0);
            FlowNode nextNode = flow.getNode(nextNodeId);
            if (nextNode == null) {
                text = text.append(Util.parseTranslatableText("fmod.flow.node.connect", Util.parseTranslatableText("fmod.misc.null")));
            } else {
                text = text.append(Util.parseTranslatableText("fmod.flow.node.connect", nextNode.name));
            }
        } else {
            // List all branches and show their next nodes
            for (int i = 0; i < this.metadata.branchNumber; i++) {
                long nextNodeId = this.nextNodeIds.get(i);
                MutableText branchLine = Util.parseTranslatableText("fmod.flow.node.branch", this.metadata.branchNames.get(i), this.metadata.branchDescriptions.get(i));
                // Show optional info about the next node
                FlowNode nextNode = flow.getNode(nextNodeId);
                if (nextNode != null) {
                    MutableText connectText = Util.parseTranslatableText("fmod.flow.node.connect", nextNode.name);
                    branchLine = branchLine.append(" (").append(connectText).append(")");
                }
                text = text.append(branchLine).append("\n");
            }
        }
        return text;
    }
}
