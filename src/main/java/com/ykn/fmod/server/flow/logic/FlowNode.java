/**
 * Copyright (c) ykn
 * This file is under the MIT License
 */

package com.ykn.fmod.server.flow.logic;

import java.util.ArrayList;
import java.util.List;

import com.ykn.fmod.server.base.util.Util;
import com.ykn.fmod.server.flow.tool.NodeRegistry;

import net.minecraft.network.chat.Component;
import net.minecraft.network.chat.MutableComponent;

/**
 * Represents a node in a logic flow that can process inputs, produce outputs, and connect to other nodes.
 * <p>
 * FlowNode is the base class for all nodes in the logic flow system. Each node has:
 * <ul>
 *   <li>A unique identifier (id)</li>
 *   <li>Input ports that can reference constants or outputs from other nodes</li>
 *   <li>Output ports that produce values during execution</li>
 *   <li>Branch connections to next nodes in the flow</li>
 *   <li>Metadata describing the node's interface and properties</li>
 * </ul>
 * <p>
 * Nodes are executed within an {@link ExecutionContext} and can be connected together to form
 * complex logic flows. Subclasses should override {@link #onExecute} to implement specific functionality.
 * <p>
 * This class implements {@link Cloneable} to support flow duplication.
 * 
 * @see ExecutionContext
 * @see LogicFlow
 * @see DataReference
 * @see NodeMetadata
 */
public class FlowNode implements Cloneable {

    /**
     * The unique identifier for this node within its logic flow.
     * This ID is generated by the {@link LogicFlow} and must be unique within that flow.
     */
    private final long id;

    /**
     * The type name of this node, used for node registration and factory creation.
     * This should match the type name used in {@link com.ykn.fmod.server.flow.tool.NodeRegistry}.
     */
    protected String type;

    /**
     * The user-defined name of this node instance.
     * This name can be used to identify the node in the UI and for debugging purposes.
     */
    public String name;

    /**
     * The static information about this node.
     * Should not be serialized because it just contains the static information about this node type.
     * We can already have this information from the type of this node.
     * <p>
     * The metadata includes:
     * <ul>
     *   <li>Display name and description for UI rendering</li>
     *   <li>Number of inputs, outputs, and branches</li>
     *   <li>Names and descriptions for each input, output, and branch</li>
     *   <li>Data type information for inputs and outputs</li>
     * </ul>
     */
    protected final transient NodeMetadata metadata;

    /**
     * The list of input data references for this node.
     * Each input can be either a constant value or a reference to another node's output.
     * 
     * @see DataReference
     */
    private List<DataReference> inputs;

    /**
     * The list of IDs of the next nodes to execute after this node.
     * Each entry corresponds to a branch from this node. A value of -1 indicates no next node.
     * The number of entries matches the branch number defined in the metadata.
     */
    public List<Long> nextNodeIds;

    /**
     * Constructs a new FlowNode with the specified configuration.
     * <p>
     * This constructor initializes:
     * <ul>
     *   <li>All inputs with empty references</li>
     *   <li>All next node IDs to -1 (no connection)</li>
     *   <li>The node metadata by calling {@link #createMetadata}</li>
     * </ul>
     * 
     * @param id The unique identifier for this node
     * @param name The user-defined name for this node
     * @param inputNumber The number of input ports this node has
     * @param outputNumber The number of output ports this node has
     * @param branchNumber The number of branch connections this node has
     */
    public FlowNode(long id, String name, int inputNumber, int outputNumber, int branchNumber) {
        this.id = id;
        this.type = "AbstractNode";
        this.name = name;
        this.inputs = new ArrayList<>();
        for (int i = 0; i < inputNumber; i++) {
            this.inputs.add(DataReference.createEmptyReference());
        }
        this.nextNodeIds = new ArrayList<>();
        for (int i = 0; i < branchNumber; i++) {
            this.nextNodeIds.add(-1L);
        }
        this.metadata = createMetadata(inputNumber, outputNumber, branchNumber);
    }

    /**
     * Creates the metadata for this node type.
     * <p>
     * Subclasses should override this method to provide specific metadata for their node type,
     * including custom display names, descriptions, and input/output specifications.
     * The default implementation creates generic metadata with placeholder text.
     * 
     * @param inputNumber The number of inputs for this node
     * @param outputNumber The number of outputs for this node
     * @param branchNumber The number of branches for this node
     * @return A NodeMetadata object containing the static information about this node
     */
    protected NodeMetadata createMetadata(int inputNumber, int outputNumber, int branchNumber) {
        // Should be overridden by subclasses to provide specific metadata
        Component displayName = Util.parseTranslatableText("fmod.node.abstract.title.name");
        Component description = Util.parseTranslatableText("fmod.node.abstract.title.feat");
        List<Component> inputNames = new ArrayList<>();
        List<Component> inputDescriptions = new ArrayList<>();
        List<Component> inputDataTypes = new ArrayList<>();
        for (int i = 0; i < inputNumber; i++) {
            inputNames.add(Util.parseTranslatableText("fmod.node.abstract.input.name", String.valueOf(i)));
            inputDescriptions.add(Util.parseTranslatableText("fmod.node.abstract.input.feat", String.valueOf(i)));
            inputDataTypes.add(Util.parseTranslatableText("fmod.node.abstract.input.type"));
        }
        List<Component> outputNames = new ArrayList<>();
        List<Component> outputDescriptions = new ArrayList<>();
        List<Component> outputDataTypes = new ArrayList<>();
        for (int i = 0; i < outputNumber; i++) {
            outputNames.add(Util.parseTranslatableText("fmod.node.abstract.output.name", String.valueOf(i)));
            outputDescriptions.add(Util.parseTranslatableText("fmod.node.abstract.output.feat", String.valueOf(i)));
            outputDataTypes.add(Util.parseTranslatableText("fmod.node.abstract.output.type"));
        }
        List<Component> branchNames = new ArrayList<>();
        List<Component> branchDescriptions = new ArrayList<>();
        for (int i = 0; i < branchNumber; i++) {
            branchNames.add(Util.parseTranslatableText("fmod.node.abstract.branch.name", String.valueOf(i)));
            branchDescriptions.add(Util.parseTranslatableText("fmod.node.abstract.branch.feat", String.valueOf(i)));
        }
        return new NodeMetadata(inputNumber, outputNumber, branchNumber, displayName, description, 
            inputNames, inputDescriptions, inputDataTypes, outputNames, outputDescriptions, outputDataTypes, branchNames, branchDescriptions);
    } 

    /**
     * Resolves all input references to their actual values.
     * <p>
     * This method iterates through all inputs and resolves each {@link DataReference}
     * to its actual value, either from a constant or from another node's output.
     * 
     * @param context The execution context containing node statuses and variables
     * @return A list of resolved input values in the same order as the inputs
     * @throws LogicException If any input reference is null or cannot be resolved
     */
    protected List<Object> resolveInputs(ExecutionContext context) throws LogicException {
        List<Object> resolvedInputs = new ArrayList<>();
        for (DataReference inputRef : inputs) {
            if (inputRef == null) {
                throw new LogicException(null, Util.parseTranslatableText("fmod.flow.error.nullinput", this.name), null);
            } else {
                Object resolvedValue = inputRef.resolve(context, this);
                resolvedInputs.add(resolvedValue);
            }
        }
        return resolvedInputs;
    }

    /**
     * Executes this node within the given execution context.
     * <p>
     * The execution process:
     * <ol>
     *   <li>Retrieves the node status from the context</li>
     *   <li>Resolves all input values</li>
     *   <li>Calls {@link #onExecute} to perform node-specific logic</li>
     *   <li>Determines the next node to execute</li>
     *   <li>Marks the node as executed and records the next branch</li>
     * </ol>
     * <p>
     * Note: A node can be executed multiple times in the same context due to loops.
     * 
     * @param context The execution context containing flow state and variables
     * @return The next node to execute, or null if the flow should terminate
     * @throws LogicException If an error occurs during execution
     */
    public FlowNode execute(ExecutionContext context) throws LogicException {
        // Executed multiple times is expected because we allow loops in logic flows, so no need to check hasExecuted here.
        NodeStatus status = context.getNodeStatus(this.id);
        List<Object> resolvedInputs = resolveInputs(context);
        status.inputs = resolvedInputs;
        this.onExecute(context, status, resolvedInputs);
        long nextNodeId = this.getNextNodeId(context, status, resolvedInputs);
        status.setExecuted();
        status.nextBranchId = nextNodeId;
        return context.getFlow().getNode(nextNodeId);
    }

    /**
     * Performs the node-specific execution logic.
     * <p>
     * Subclasses should override this method to implement their specific functionality.
     * This method should:
     * <ul>
     *   <li>Process the resolved input values</li>
     *   <li>Write output values using {@link #setOutput}</li>
     *   <li>Throw {@link LogicException} if errors occur</li>
     * </ul>
     * <p>
     * The default implementation does nothing.
     * 
     * @param context The execution context
     * @param status The status object for this node in the current execution
     * @param resolvedInputs The list of resolved input values
     * @throws LogicException If an error occurs during node execution
     */
    protected void onExecute(ExecutionContext context, NodeStatus status, List<Object> resolvedInputs) throws LogicException {
        // To be overridden by subclasses to implement specific node logic
    }

    /**
     * Gets the unique identifier of this node.
     * 
     * @return The node's unique ID within its logic flow
     */
    public long getId() {
        return this.id;
    }

    /**
     * Gets the type name of this node.
     * 
     * @return The type string used for node registration
     */
    public String getType() {
        return this.type;
    }

    /**
     * Gets the metadata describing this node's interface.
     * 
     * @return The NodeMetadata object containing static information about this node
     */
    public NodeMetadata getMetadata() {
        return this.metadata;
    }

    /**
     * Gets the data reference for the specified input port.
     * 
     * @param index The index of the input port (0-based)
     * @return The DataReference for the specified input
     * @throws IndexOutOfBoundsException If the index is out of range
     */
    public DataReference getInput(int index) {
        return inputs.get(index);
    }

    /**
     * Sets the data reference for the specified input port.
     * 
     * @param index The index of the input port (0-based)
     * @param reference The DataReference to assign to this input
     * @throws IndexOutOfBoundsException If the index is out of range
     */
    public void setInput(int index, DataReference reference) {
        inputs.set(index, reference);
    }

    /**
     * Gets the output value from the specified output port.
     * <p>
     * This method can only be called after the node has been executed in the given context.
     * 
     * @param context The execution context
     * @param index The index of the output port (0-based)
     * @return The output value
     * @throws LogicException If the node has not been executed yet
     * @throws IndexOutOfBoundsException If the index is out of range
     */
    public Object getOutput(ExecutionContext context, int index) throws LogicException {
        NodeStatus status = context.getNodeStatus(this.id);
        if (status.hasExecuted == false) {
            throw new LogicException(null, Util.parseTranslatableText("fmod.flow.error.notexecuted", this.name), null);
        }
        return status.outputs.get(index);
    }

    /**
     * Sets the output value for the specified output port.
     * <p>
     * This method should be called from within {@link #onExecute} to produce output values.
     * 
     * @param context The execution context
     * @param index The index of the output port (0-based)
     * @param value The value to set as output
     */
    protected void setOutput(ExecutionContext context, int index, Object value) {
        NodeStatus status = context.getNodeStatus(this.id);
        status.setOutput(index, value);
    }

    /**
     * This method indicates whether this node is an event node.
     * Event nodes should always be the starting point of a logic flow execution.
     * And the event nodes will be automatically triggered by the system when the corresponding event occurs.
     * By default, nodes are not event nodes. Override this method in subclasses to specify event nodes.
     * @return true if this node is an event node, false otherwise
     */
    public boolean isEventNode() {
        // Override in subclasses to specify event nodes
        return false;
    }

    /**
     * Determines the ID of the next node to execute based on this node's logic.
     * <p>
     * The default implementation returns the first branch (index 0).
     * Nodes with multiple branches (e.g., conditional nodes) should override this
     * to return the appropriate branch based on their logic.
     * 
     * @param context The execution context
     * @param status The status object for this node
     * @param resolvedInputs The list of resolved input values
     * @return The ID of the next node to execute, or -1 to terminate the flow
     * @throws LogicException If an error occurs while determining the next node
     */
    public long getNextNodeId(ExecutionContext context, NodeStatus status, List<Object> resolvedInputs) throws LogicException {
        // Should be overridden to return the correct next node ID based on the node logic
        return nextNodeIds.get(0);
    }
    
    /**
     * Sets the next node ID for the specified branch.
     * 
     * @param branchIndex The index of the branch (0-based)
     * @param nodeId The ID of the next node, or -1 for no connection
     * @throws IndexOutOfBoundsException If the branch index is out of range
     */
    public void setNextNodeId(int branchIndex, long nodeId) {
        this.nextNodeIds.set(branchIndex, nodeId);
    }

    /**
     * Creates a deep copy of this node.
     * <p>
     * The copy includes:
     * <ul>
     *   <li>All input references (copied)</li>
     *   <li>All next node IDs</li>
     *   <li>The same ID, name, and type</li>
     * </ul>
     * <p>
     * Note: This uses {@link com.ykn.fmod.server.flow.tool.NodeRegistry} to preserve
     * the correct subclass type.
     * 
     * @return A new FlowNode instance with the same configuration
     */
    public FlowNode copy() {
        // Need to keep child class type here, so using NodeRegistry instead of new FlowNode(...)
        FlowNode newNode = NodeRegistry.createNode(this.type, this.id, this.name);
        for (int i = 0; i < this.metadata.inputNumber; i++) {
            DataReference inputRef = this.inputs.get(i);
            newNode.inputs.set(i, inputRef.copy());
        }
        for (int i = 0; i < this.nextNodeIds.size(); i++) {
            long nextNodeId = this.nextNodeIds.get(i);
            newNode.nextNodeIds.set(i, nextNodeId);
        }
        return newNode;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return this.copy();
    }

    /**
     * Renders the static information about this node as displayable text.
     * <p>
     * The rendered text includes:
     * <ul>
     *   <li>Node name, display name, and description</li>
     *   <li>All input ports with their sources (constants or node outputs)</li>
     *   <li>All output ports with their descriptions</li>
     *   <li>Branch connections to next nodes</li>
     * </ul>
     * <p>
     * Note: This only renders static information. To render execution status,
     * use {@link NodeStatus#render(long, LogicFlow)} instead.
     * 
     * @param flow The logic flow containing this node (used to resolve node references)
     * @return A Text object suitable for display in Minecraft
     */
    public Component render(LogicFlow flow) {
        // Render title
        MutableComponent text = Util.parseTranslatableText("fmod.flow.node.title", this.name, this.metadata.displayName, this.metadata.description);
        text = text.append("\n");
        // Render inputs
        for (int i = 0; i < this.metadata.inputNumber; i++) {
            DataReference inputRef = this.inputs.get(i);
            MutableComponent inputLine = Util.parseTranslatableText("fmod.flow.node.input", this.metadata.inputNames.get(i), this.metadata.inputDescriptions.get(i));
            // Render optional info about the input source
            if (inputRef != null) {
                if (inputRef.type == DataReference.ReferenceType.CONSTANT && inputRef.value != null) {
                    inputLine = inputLine.append(" (");
                    inputLine = inputLine.append(Util.parseTranslatableText("fmod.flow.node.const", String.valueOf(inputRef.value)));
                    inputLine = inputLine.append(")");
                } else if (inputRef.type == DataReference.ReferenceType.NODE_OUTPUT) {
                    FlowNode refNode = flow.getNode(inputRef.referenceId);
                    if (refNode != null) {
                        inputLine = inputLine.append(" (");
                        inputLine = inputLine.append(Util.parseTranslatableText("fmod.flow.node.from", refNode.name, refNode.metadata.outputNames.get(inputRef.referenceIndex)));
                        inputLine = inputLine.append(")");
                    }
                }
            }
            text = text.append(inputLine).append("\n");
        }
        // Render outputs
        for (int i = 0; i < this.metadata.outputNumber; i++) {
            MutableComponent outputLine = Util.parseTranslatableText("fmod.flow.node.output", this.metadata.outputNames.get(i), this.metadata.outputDescriptions.get(i));
            text = text.append(outputLine).append("\n");
        }
        // Render branches
        if (this.metadata.branchNumber == 1) {
            // Directly show the next node
            long nextNodeId = this.nextNodeIds.get(0);
            if (flow.getNode(nextNodeId) == null) {
                text = text.append(Util.parseTranslatableText("fmod.flow.node.connect", Util.parseTranslatableText("fmod.misc.null")));
            } else {
                FlowNode nextNode = flow.getNode(nextNodeId);
                text = text.append(Util.parseTranslatableText("fmod.flow.node.connect", nextNode.name));
            }
        } else {
            // List all branches and show their next nodes
            for (int i = 0; i < this.metadata.branchNumber; i++) {
                long nextNodeId = this.nextNodeIds.get(i);
                MutableComponent branchLine = Util.parseTranslatableText("fmod.flow.node.branch", this.metadata.branchNames.get(i), this.metadata.branchDescriptions.get(i));
                // Show optional info about the next node
                if (flow.getNode(nextNodeId) != null) {
                    FlowNode nextNode = flow.getNode(nextNodeId);
                    MutableComponent connectText = Util.parseTranslatableText("fmod.flow.node.connect", nextNode.name);
                    branchLine = branchLine.append(" (").append(connectText).append(")");
                }
                text = text.append(branchLine).append("\n");
            }
        }
        return text;
    }
}
