/**
 * Copyright (c) ykn
 * This file is under the MIT License
 */

package com.ykn.fmod.server.flow.logic;

import java.util.ArrayList;
import java.util.List;

import com.ykn.fmod.server.base.util.Util;

import net.minecraft.network.chat.Component;
import net.minecraft.network.chat.MutableComponent;

/**
 * Tracks the execution state of a single node within an {@link ExecutionContext}.
 * <p>
 * Each NodeStatus stores:
 * <ul>
 *   <li>The associated FlowNode (reference only)</li>
 *   <li>The resolved input values for the current/last execution</li>
 *   <li>The generated output values from the current/last execution</li>
 *   <li>Whether the node has been executed</li>
 *   <li>Which branch was taken (next node ID)</li>
 * </ul>
 * <p>
 * NodeStatus objects are created by ExecutionContext at the start of execution,
 * with one status per node. They are updated during execution and can be copied
 * to create snapshots of execution state.
 * <p>
 * This class is separate from FlowNode to allow multiple simultaneous executions
 * of the same flow with different states.
 * 
 * @see FlowNode
 * @see ExecutionContext
 */
public class NodeStatus implements Cloneable {

    /**
     * The FlowNode associated with this status.
     * This is a reference to the actual node, not a copy.
     */
    public FlowNode node;

    /**
     * The resolved input values for this node's execution.
     * Each element corresponds to an input port on the node.
     * Values are resolved from DataReferences before execution.
     */
    public List<Object> inputs;

    /**
     * Whether this node has been executed in the current execution context.
     * Set to true after {@link FlowNode#execute(ExecutionContext)} completes.
     */
    public boolean hasExecuted;

    /**
     * The output values generated by this node's execution.
     * Each element corresponds to an output port on the node.
     * Values are set by the node during {@link FlowNode#onExecute}.
     */
    public List<Object> outputs;

    /**
     * The ID of the next node to execute (the branch taken).
     * Set to -1 if no next node or if not yet executed.
     */
    public long nextBranchId;

    /**
     * Creates a new NodeStatus for the specified node.
     * <p>
     * Initializes:
     * <ul>
     *   <li>Input list with null values (one per input port)</li>
     *   <li>Output list with null values (one per output port)</li>
     *   <li>hasExecuted to false</li>
     *   <li>nextBranchId to -1</li>
     * </ul>
     * 
     * @param node The FlowNode this status tracks
     */
    public NodeStatus(FlowNode node) {
        this.node = node;
        int inputNumber = node.metadata.inputNumber;
        this.inputs = new ArrayList<>();
        for (int i = 0; i < inputNumber; i++) {
            this.inputs.add(null);
        }
        this.hasExecuted = false;
        int outputNumber = node.metadata.outputNumber;
        this.outputs = new ArrayList<>();
        for (int i = 0; i < outputNumber; i++) {
            this.outputs.add(null);
        }
        this.nextBranchId = -1;
    }

    /**
     * Creates a shallow copy of this NodeStatus.
     * <p>
     * The copy includes:
     * <ul>
     *   <li>The same node reference (not copied)</li>
     *   <li>Copied lists of inputs and outputs (but values themselves are not deep copied)</li>
     *   <li>The execution state and next branch ID</li>
     * </ul>
     * <p>
     * This is used to create execution history snapshots.
     * 
     * @return A new NodeStatus with copied state
     */
    public NodeStatus copy() {
        NodeStatus cloned = new NodeStatus(node);
        int inputNumber = node.metadata.inputNumber;
        cloned.inputs = new ArrayList<>();
        for (int i = 0; i < inputNumber; i++) {
            cloned.inputs.add(this.inputs.get(i));
        }
        cloned.hasExecuted = this.hasExecuted;
        int outputNumber = node.metadata.outputNumber;
        cloned.outputs = new ArrayList<>();
        for (int i = 0; i < outputNumber; i++) {
            cloned.outputs.add(this.outputs.get(i));
        }
        cloned.nextBranchId = this.nextBranchId;
        return cloned;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return this.copy();
    }

    /**
     * Marks this node as having been executed.
     * <p>
     * Called by {@link FlowNode#execute(ExecutionContext)} after successful execution.
     */
    public void setExecuted() {
        this.hasExecuted = true;
    }

    /**
     * Resets this status to its initial state.
     * <p>
     * This clears:
     * <ul>
     *   <li>All input values (set to null)</li>
     *   <li>All output values (set to null)</li>
     *   <li>The execution flag (set to false)</li>
     *   <li>The next branch ID (set to -1)</li>
     * </ul>
     * <p>
     * Called by {@link ExecutionContext#resetExecutionStatus()}.
     */
    public void reset() {
        for (int i = 0; i < this.inputs.size(); i++) {
            this.inputs.set(i, null);
        }
        this.hasExecuted = false;
        for (int i = 0; i < this.outputs.size(); i++) {
            this.outputs.set(i, null);
        }
        this.nextBranchId = -1;
    }

    /**
     * Sets the value for a specific output port.
     * <p>
     * Called by nodes during execution to produce output values.
     * 
     * @param index The output port index (0-based)
     * @param value The value to set (can be null)
     * @throws IndexOutOfBoundsException If the index is out of range
     */
    public void setOutput(int index, Object value) {
        this.outputs.set(index, value);
    }

    /**
     * Renders the execution status of this node as displayable text.
     * <p>
     * The rendered text includes:
     * <ul>
     *   <li>The node's position in the execution sequence</li>
     *   <li>The node name and display name</li>
     *   <li>All resolved input values</li>
     *   <li>All generated output values</li>
     *   <li>The next node in the execution path</li>
     * </ul>
     * <p>
     * This is useful for debugging and understanding what happened during execution.
     * <p>
     * Note: This renders dynamic execution data. To render static node information,
     * use {@link FlowNode#render(LogicFlow)} instead.
     * 
     * @param index The position of this node in the execution sequence (for display)
     * @param flow The logic flow (used to resolve next node references)
     * @return A Text object suitable for display in Minecraft
     */
    public Component render(long index, LogicFlow flow) {
        // Render title
        MutableComponent text = Util.parseTranslatableText("fmod.flow.execute.node", String.valueOf(index), this.node.name, this.node.metadata.displayName);
        text = text.append("\n");
        // Render inputs
        for (int i = 0; i < this.node.metadata.inputNumber; i++) {
            Object inputValue = this.inputs.get(i);
            if (inputValue == null) {
                text = text.append(Util.parseTranslatableText("fmod.flow.execute.input", this.node.metadata.inputNames.get(i), Util.parseTranslatableText("fmod.misc.null")));
            } else {
                text = text.append(Util.parseTranslatableText("fmod.flow.execute.input", this.node.metadata.inputNames.get(i), String.valueOf(inputValue)));
            }
            text = text.append("\n");
        }
        // Render outputs
        for (int i = 0; i < this.node.metadata.outputNumber; i++) {
            Object outputValue = this.outputs.get(i);
            if (outputValue == null) {
                text = text.append(Util.parseTranslatableText("fmod.flow.execute.output", this.node.metadata.outputNames.get(i), Util.parseTranslatableText("fmod.misc.null")));
            } else {
                text = text.append(Util.parseTranslatableText("fmod.flow.execute.output", this.node.metadata.outputNames.get(i), String.valueOf(outputValue)));
            }
            text = text.append("\n");
        }
        // Render next node
        FlowNode nextNode = flow.getNode(this.nextBranchId);
        if (nextNode == null) {
            text = text.append(Util.parseTranslatableText("fmod.flow.execute.next", Util.parseTranslatableText("fmod.misc.null")));
        } else {
            text = text.append(Util.parseTranslatableText("fmod.flow.execute.next", nextNode.name));
        }
        return text;
    }
}
